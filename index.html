<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flooring Takeoff (MVP + Auto Dimension Reader)</title>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.js"></script>

  <!-- Tesseract.js (OCR in browser) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    :root { --bg:#f6f7f9; --card:#fff; --line:#e6e8ee; --text:#111827; --muted:#6b7280; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: var(--bg); color: var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; }
    header { display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    h1 { margin: 0; font-size: 18px; }
    .grid { display:grid; grid-template-columns: 1.35fr 0.65fr; gap: 14px; margin-top: 12px; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }

    .card { background: var(--card); border: 1px solid var(--line); border-radius: 12px; padding: 12px; }
    .row { display:grid; grid-template-columns: repeat(12, 1fr); gap: 10px; }
    .col-12{ grid-column: span 12; } .col-6{ grid-column: span 6; } .col-4{ grid-column: span 4; } .col-3{ grid-column: span 3; }
    @media (max-width: 680px){ .col-6,.col-4,.col-3{ grid-column: span 12; } }

    label { display:block; font-size: 12px; color: var(--muted); margin: 0 0 6px; }
    input, select, button {
      width:100%; box-sizing:border-box; padding:10px; border: 1px solid #d7dbe6; border-radius: 10px; font-size: 14px;
      background:#fff;
    }
    button { cursor:pointer; background:#111827; color:#fff; border:1px solid #111827; }
    button.secondary { background:#fff; color:#111827; border-color:#cfd5e5; }
    button.ghost { background:#fff; color:#111827; border-color:#e5e7eb; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    .hint { font-size: 12px; color: var(--muted); line-height: 1.35; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; border:1px solid var(--line); border-radius: 999px; font-size: 12px; color: var(--muted); background:#fff; }
    .toolbar { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top: 10px; }
    .toolbar > * { flex: 1 1 160px; }

    .viewer {
      position: relative;
      width: 100%;
      height: 72vh;
      min-height: 520px;
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      background: #0b1220;
      touch-action: none;
    }
    @media (max-width: 980px){
      .viewer { height: 65vh; min-height: 480px; }
    }

    canvas { display:block; }
    #baseCanvas, #overlayCanvas {
      position:absolute; left:0; top:0;
      transform-origin: 0 0;
    }

    .status { display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .list { display:flex; flex-direction:column; gap:10px; margin-top: 10px; }
    .item { border: 1px solid var(--line); border-radius: 12px; padding: 10px; }
    .itemHead { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .item strong { font-size: 14px; }
    .item small { color: var(--muted); }
    .itemBtns { display:flex; gap:8px; flex-wrap:wrap; }
    .big { font-size: 18px; font-weight: 800; }
    .line { display:flex; justify-content:space-between; gap:12px; padding: 8px 0; border-bottom: 1px dashed var(--line); }
    .line:last-child { border-bottom:none; }

    .notice { padding: 10px; border-radius: 10px; border: 1px solid var(--line); background: #fff; }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>Flooring Takeoff (Upload → Auto-read dimension → Auto-scale → Trace → Boxes)</h1>
      <span class="pill">OCR-assisted (click to confirm)</span>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <section class="card">
        <div class="row">
          <div class="col-6">
            <label>Upload blueprint (PDF / JPG / PNG)</label>
            <input id="fileInput" type="file" accept=".pdf,image/*" />
          </div>
          <div class="col-3">
            <label>Mode</label>
            <select id="modeSelect">
              <option value="pan">Pan / Zoom</option>
              <option value="calibrate">Set Scale</option>
              <option value="trace">Trace Area</option>
            </select>
          </div>
          <div class="col-3">
            <label>Room / Area name</label>
            <input id="areaName" placeholder="Living Room" />
          </div>
        </div>

        <div class="toolbar">
          <button class="secondary" type="button" id="btnDetect" disabled>Detect dimensions (OCR)</button>
          <button class="secondary" type="button" id="btnUndo">Undo point</button>
          <button class="secondary" type="button" id="btnClear">Clear current</button>
          <button type="button" id="btnFinish">Finish area</button>
          <button class="ghost" type="button" id="btnResetView">Reset view</button>
        </div>

        <div class="status">
          <span class="pill">Auto-scale target: <span class="mono" id="dimTarget">none</span></span>
          <span class="pill">Scale: <span class="mono" id="scaleReadout">not set</span></span>
          <span class="pill">Current points: <span class="mono" id="pointsReadout">0</span></span>
          <span class="pill">OCR: <span class="mono" id="ocrStatus">idle</span></span>
        </div>

        <div class="notice hint" style="margin-top:10px">
          <b>Workflow:</b>
          1) Upload blueprint → 2) Click <b>Detect dimensions</b> → 3) Click a detected dimension (list or box)
          → 4) Mode auto-switches to <b>Set Scale</b> → click the two endpoints of that dimension line → scale sets automatically.
          <br/>Then Mode: <b>Trace Area</b> → click corners → Finish area.
          <br/><span class="hint">Tip: hold <b>Shift</b> while dragging to pan in any mode.</span>
        </div>

        <div class="hint" style="margin-top:10px">
          OCR works best on clean, high-resolution PDFs/images. If it misses text, try a higher-res plan export or a PDF (not a screenshot).
        </div>

        <div style="height:12px"></div>

        <div class="viewer" id="viewer">
          <canvas id="baseCanvas"></canvas>
          <canvas id="overlayCanvas"></canvas>
        </div>
      </section>

      <!-- RIGHT -->
      <aside class="card">
        <div class="row">
          <div class="col-6">
            <label>Waste %</label>
            <input id="wastePct" type="number" step="0.1" value="10" />
          </div>
          <div class="col-6">
            <label>Sq ft per box (optional)</label>
            <input id="sqftPerBox" type="number" step="0.01" placeholder="18.6" />
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="line"><div class="hint">Subtotal (sq ft)</div><div class="mono" id="sumSubtotal">0.00</div></div>
        <div class="line"><div class="hint">Waste (sq ft)</div><div class="mono" id="sumWaste">0.00</div></div>
        <div class="line"><div class="hint">Total (sq ft)</div><div class="mono" id="sumTotal">0.00</div></div>
        <div class="line"><div class="hint">Boxes needed</div><div class="mono" id="sumBoxes">—</div></div>

        <div style="height:14px"></div>
        <div class="big">Detected Dimensions</div>
        <div class="hint">Click one to set the auto-scale target. Then click its endpoints on the plan (Mode: Set Scale).</div>
        <div class="list" id="dimsList"></div>

        <div style="height:14px"></div>
        <div class="big">Areas</div>
        <div class="list" id="areasList"></div>

        <div style="height:12px"></div>
        <button class="secondary" type="button" id="btnExport">Export JSON (dev)</button>
      </aside>
    </div>
  </div>

<script>
  // ---------------------------
  // State
  // ---------------------------
  const state = {
    imgWidth: 0,
    imgHeight: 0,

    // view transform
    scale: 1,
    minScale: 0.2,
    maxScale: 10,
    offsetX: 0,
    offsetY: 0,

    // interaction
    mode: "pan",
    dragging: false,
    lastDrag: null,

    // calibration
    calibratePts: [],
    ftPerPixel: null,
    selectedDimFeet: null,
    selectedDimId: null,

    // tracing
    currentPts: [],
    areas: [],

    // OCR detections
    dims: [], // {id, raw, feet, bbox:{x0,y0,x1,y1}, conf}
    ocrBusy: false,

    // image
    _img: null
  };

  // ---------------------------
  // DOM
  // ---------------------------
  const viewer = document.getElementById("viewer");
  const baseCanvas = document.getElementById("baseCanvas");
  const overlayCanvas = document.getElementById("overlayCanvas");
  const baseCtx = baseCanvas.getContext("2d");
  const overlayCtx = overlayCanvas.getContext("2d");

  const fileInput = document.getElementById("fileInput");
  const modeSelect = document.getElementById("modeSelect");
  const areaName = document.getElementById("areaName");

  const btnDetect = document.getElementById("btnDetect");
  const btnUndo = document.getElementById("btnUndo");
  const btnClear = document.getElementById("btnClear");
  const btnFinish = document.getElementById("btnFinish");
  const btnResetView = document.getElementById("btnResetView");
  const btnExport = document.getElementById("btnExport");

  const dimTarget = document.getElementById("dimTarget");
  const scaleReadout = document.getElementById("scaleReadout");
  const pointsReadout = document.getElementById("pointsReadout");
  const ocrStatus = document.getElementById("ocrStatus");

  const wastePctEl = document.getElementById("wastePct");
  const sqftPerBoxEl = document.getElementById("sqftPerBox");

  const sumSubtotal = document.getElementById("sumSubtotal");
  const sumWaste = document.getElementById("sumWaste");
  const sumTotal = document.getElementById("sumTotal");
  const sumBoxes = document.getElementById("sumBoxes");

  const dimsList = document.getElementById("dimsList");
  const areasList = document.getElementById("areasList");

  // ---------------------------
  // Helpers
  // ---------------------------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function dist(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }

  function polygonAreaPx2(pts){
    if (pts.length < 3) return 0;
    let sum = 0;
    for (let i=0; i<pts.length; i++){
      const j = (i+1) % pts.length;
      sum += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
    }
    return Math.abs(sum) / 2;
  }

  function screenToImage(pt){
    return { x: (pt.x - state.offsetX) / state.scale, y: (pt.y - state.offsetY) / state.scale };
  }

  function imageToScreen(pt){
    return { x: pt.x * state.scale + state.offsetX, y: pt.y * state.scale + state.offsetY };
  }

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[s]));
  }

  function updateReadouts(){
    dimTarget.textContent = state.selectedDimFeet ? `${state.selectedDimFeet.toFixed(3)} ft` : "none";
    scaleReadout.textContent = state.ftPerPixel ? `${state.ftPerPixel.toFixed(6)} ft/px` : "not set";
    pointsReadout.textContent = String(state.mode === "calibrate" ? state.calibratePts.length : state.currentPts.length);
  }

  function setOcrStatus(text){
    ocrStatus.textContent = text;
  }

  // ---------------------------
  // Canvas sizing & view
  // ---------------------------
  function resizeCanvases(){
    const dpr = window.devicePixelRatio || 1;
    const rect = viewer.getBoundingClientRect();

    baseCanvas.width = Math.floor(rect.width * dpr);
    baseCanvas.height = Math.floor(rect.height * dpr);
    overlayCanvas.width = baseCanvas.width;
    overlayCanvas.height = baseCanvas.height;

    baseCanvas.style.width = rect.width + "px";
    baseCanvas.style.height = rect.height + "px";
    overlayCanvas.style.width = rect.width + "px";
    overlayCanvas.style.height = rect.height + "px";

    baseCtx.setTransform(dpr,0,0,dpr,0,0);
    overlayCtx.setTransform(dpr,0,0,dpr,0,0);

    render();
  }

  function resetView(){
    const rect = viewer.getBoundingClientRect();
    if (!state.imgWidth || !state.imgHeight) return;

    const fit = Math.min(rect.width / state.imgWidth, rect.height / state.imgHeight);
    state.scale = clamp(fit, state.minScale, state.maxScale);
    state.offsetX = (rect.width - state.imgWidth * state.scale) / 2;
    state.offsetY = (rect.height - state.imgHeight * state.scale) / 2;
    render();
  }

  // ---------------------------
  // Rendering
  // ---------------------------
  function render(){
    const rect = viewer.getBoundingClientRect();
    baseCtx.clearRect(0,0,rect.width, rect.height);
    overlayCtx.clearRect(0,0,rect.width, rect.height);

    if (state._img){
      baseCtx.save();
      baseCtx.translate(state.offsetX, state.offsetY);
      baseCtx.scale(state.scale, state.scale);
      baseCtx.drawImage(state._img, 0, 0);
      baseCtx.restore();
    }

    // Existing areas
    for (const a of state.areas){
      drawPolygon(a.pts, "rgba(59,130,246,0.95)", "rgba(59,130,246,0.18)", true);
    }

    // Detections
    if (state.dims.length > 0){
      for (const d of state.dims){
        const isSel = d.id === state.selectedDimId;
        drawBBox(d.bbox,
          isSel ? "rgba(255, 255, 0, 0.95)" : "rgba(255, 165, 0, 0.8)",
          isSel ? "rgba(255, 255, 0, 0.14)" : "rgba(255, 165, 0, 0.12)"
        );
        drawLabelAtBBox(d.bbox, d.raw, isSel);
      }
    }

    // Current mode overlays
    if (state.mode === "calibrate"){
      drawPointsAndLine(state.calibratePts, "rgba(0,255,170,0.95)");
    } else if (state.mode === "trace"){
      if (state.currentPts.length >= 2){
        drawPolygon(state.currentPts, "rgba(16,185,129,0.95)", "rgba(16,185,129,0.18)", false);
      }
      drawPoints(state.currentPts, "rgba(16,185,129,0.95)");
    }
  }

  function drawPoints(pts, color){
    overlayCtx.save();
    overlayCtx.fillStyle = color;
    for (const p of pts){
      const s = imageToScreen(p);
      overlayCtx.beginPath();
      overlayCtx.arc(s.x, s.y, 4, 0, Math.PI*2);
      overlayCtx.fill();
    }
    overlayCtx.restore();
  }

  function drawPointsAndLine(pts, color){
    overlayCtx.save();
    overlayCtx.strokeStyle = color;
    overlayCtx.lineWidth = 2;
    drawPoints(pts, color);
    if (pts.length === 2){
      const a = imageToScreen(pts[0]);
      const b = imageToScreen(pts[1]);
      overlayCtx.beginPath();
      overlayCtx.moveTo(a.x, a.y);
      overlayCtx.lineTo(b.x, b.y);
      overlayCtx.stroke();
    }
    overlayCtx.restore();
  }

  function drawPolygon(pts, stroke, fill, closed=true){
    if (pts.length < 2) return;
    overlayCtx.save();
    overlayCtx.strokeStyle = stroke;
    overlayCtx.fillStyle = fill;
    overlayCtx.lineWidth = 2;

    const p0 = imageToScreen(pts[0]);
    overlayCtx.beginPath();
    overlayCtx.moveTo(p0.x, p0.y);
    for (let i=1; i<pts.length; i++){
      const s = imageToScreen(pts[i]);
      overlayCtx.lineTo(s.x, s.y);
    }
    if (closed && pts.length >= 3) overlayCtx.closePath();
    overlayCtx.stroke();
    if (closed && pts.length >= 3) overlayCtx.fill();
    overlayCtx.restore();
  }

  function drawBBox(b, stroke, fill){
    const p0 = imageToScreen({x:b.x0, y:b.y0});
    const p1 = imageToScreen({x:b.x1, y:b.y1});
    const x = Math.min(p0.x,p1.x), y = Math.min(p0.y,p1.y);
    const w = Math.abs(p1.x-p0.x), h = Math.abs(p1.y-p0.y);

    overlayCtx.save();
    overlayCtx.strokeStyle = stroke;
    overlayCtx.fillStyle = fill;
    overlayCtx.lineWidth = 2;
    overlayCtx.beginPath();
    overlayCtx.rect(x,y,w,h);
    overlayCtx.fill();
    overlayCtx.stroke();
    overlayCtx.restore();
  }

  function drawLabelAtBBox(b, text, isSelected){
    const p0 = imageToScreen({x:b.x0, y:b.y0});
    const x = p0.x + 4;
    const y = p0.y - 6;

    overlayCtx.save();
    overlayCtx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    overlayCtx.fillStyle = isSelected ? "rgba(255,255,0,0.95)" : "rgba(255,165,0,0.9)";
    overlayCtx.fillText(text, x, y);
    overlayCtx.restore();
  }

  // ---------------------------
  // File loading
  // ---------------------------
  fileInput.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    clearAllData();

    if (file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf")){
      await loadPdfFirstPage(file);
    } else {
      await loadImageFile(file);
    }

    btnDetect.disabled = !state._img;
    resizeCanvases();
    resetView();
    updateReadouts();
    renderDimsList();
    renderAreasList();
    recalcSummary();
  });

  function clearAllData(){
    state._img = null;
    state.imgWidth = 0;
    state.imgHeight = 0;

    state.ftPerPixel = null;
    state.calibratePts = [];
    state.currentPts = [];

    state.areas = [];
    state.dims = [];
    state.selectedDimFeet = null;
    state.selectedDimId = null;

    state.ocrBusy = false;
    btnDetect.disabled = true;

    setOcrStatus("idle");
    updateReadouts();
    renderDimsList();
    renderAreasList();
    render();
    recalcSummary();
  }

  async function loadImageFile(file){
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.crossOrigin = "anonymous";
    await new Promise((res, rej) => {
      img.onload = res;
      img.onerror = rej;
      img.src = url;
    });
    state._img = img;
    state.imgWidth = img.naturalWidth;
    state.imgHeight = img.naturalHeight;
    URL.revokeObjectURL(url);
  }

  async function loadPdfFirstPage(file){
    const arr = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arr }).promise;
    const page = await pdf.getPage(1);

    // Higher scale = better OCR (but heavier)
    const viewport = page.getViewport({ scale: 3.0 });

    const off = document.createElement("canvas");
    off.width = Math.floor(viewport.width);
    off.height = Math.floor(viewport.height);
    const ctx = off.getContext("2d");

    await page.render({ canvasContext: ctx, viewport }).promise;

    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = off.toDataURL("image/png");
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });

    state._img = img;
    state.imgWidth = img.naturalWidth;
    state.imgHeight = img.naturalHeight;
  }

  // ---------------------------
  // Modes & buttons
  // ---------------------------
  modeSelect.addEventListener("change", () => {
    state.mode = modeSelect.value;
    state.dragging = false;
    state.lastDrag = null;
    updateReadouts();
    render();
  });

  btnResetView.addEventListener("click", resetView);

  btnUndo.addEventListener("click", () => {
    if (state.mode === "calibrate") state.calibratePts.pop();
    if (state.mode === "trace") state.currentPts.pop();
    updateReadouts();
    render();
  });

  btnClear.addEventListener("click", () => {
    state.calibratePts = [];
    state.currentPts = [];
    updateReadouts();
    render();
  });

  btnFinish.addEventListener("click", () => {
    if (state.mode === "calibrate") finishCalibration();
    if (state.mode === "trace") finishArea();
  });

  viewer.addEventListener("dblclick", (e) => {
    if (state.mode === "trace"){
      e.preventDefault();
      finishArea();
    }
  });

  // ---------------------------
  // Interaction: click points + pan/zoom
  // ---------------------------
  viewer.addEventListener("pointerdown", (e) => {
    if (!state._img) return;
    viewer.setPointerCapture(e.pointerId);

    const pt = getViewerPoint(e);

    if (state.mode === "pan" || e.shiftKey){
      state.dragging = true;
      state.lastDrag = pt;
      return;
    }

    const imgPt = screenToImage(pt);
    if (imgPt.x < 0 || imgPt.y < 0 || imgPt.x > state.imgWidth || imgPt.y > state.imgHeight) return;

    // If click on a detection bbox, select it (any mode)
    const clickedDim = findClickedDim(imgPt);
    if (clickedDim){
      selectDim(clickedDim.id);
      // Continue (user can still place points)
    }

    if (state.mode === "calibrate"){
      if (state.calibratePts.length < 2){
        state.calibratePts.push(imgPt);
        updateReadouts();
        render();
        if (state.calibratePts.length === 2) finishCalibration();
      }
      return;
    }

    if (state.mode === "trace"){
      state.currentPts.push(imgPt);
      updateReadouts();
      render();
      return;
    }
  });

  viewer.addEventListener("pointermove", (e) => {
    if (!state._img) return;
    if (!state.dragging) return;

    const pt = getViewerPoint(e);
    const dx = pt.x - state.lastDrag.x;
    const dy = pt.y - state.lastDrag.y;

    state.offsetX += dx;
    state.offsetY += dy;
    state.lastDrag = pt;
    render();
  });

  viewer.addEventListener("pointerup", () => {
    state.dragging = false;
    state.lastDrag = null;
  });

  viewer.addEventListener("wheel", (e) => {
    if (!state._img) return;
    e.preventDefault();

    const rect = viewer.getBoundingClientRect();
    const mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top };

    const zoomFactor = (e.deltaY < 0) ? 1.10 : 0.90;
    const newScale = clamp(state.scale * zoomFactor, state.minScale, state.maxScale);

    // zoom around cursor
    const before = screenToImage(mouse);
    state.scale = newScale;
    const after = screenToImage(mouse);

    state.offsetX += (after.x - before.x) * state.scale;
    state.offsetY += (after.y - before.y) * state.scale;

    render();
  }, { passive: false });

  function getViewerPoint(e){
    const rect = viewer.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  // ---------------------------
  // Calibration (auto if selectedDimFeet)
  // ---------------------------
  function finishCalibration(){
    if (state.calibratePts.length !== 2) return;

    const px = dist(state.calibratePts[0], state.calibratePts[1]);
    if (px <= 0) return;

    if (state.selectedDimFeet && state.selectedDimFeet > 0){
      state.ftPerPixel = state.selectedDimFeet / px;
      state.calibratePts = [];
      updateReadouts();
      render();
      recalcSummary();
      return;
    }

    // Fallback manual
    const input = prompt("Enter the REAL distance between those two points (in FEET). Example: 12.5");
    if (input == null) return;

    const feet = parseFloat(input);
    if (!Number.isFinite(feet) || feet <= 0){
      alert("Invalid feet value.");
      return;
    }

    state.ftPerPixel = feet / px;
    state.calibratePts = [];
    updateReadouts();
    render();
    recalcSummary();
  }

  // ---------------------------
  // Trace area
  // ---------------------------
  function finishArea(){
    if (!state.ftPerPixel){
      alert("Set the scale first (Mode: Set Scale).");
      return;
    }
    if (state.currentPts.length < 3){
      alert("Trace at least 3 points to make an area.");
      return;
    }

    const name = areaName.value.trim() || `Area ${state.areas.length + 1}`;
    const px2 = polygonAreaPx2(state.currentPts);
    const ft2 = px2 * (state.ftPerPixel * state.ftPerPixel);

    state.areas.push({
      name,
      pts: structuredClone(state.currentPts),
      areaSqft: ft2
    });

    state.currentPts = [];
    updateReadouts();
    renderAreasList();
    render();
    recalcSummary();
  }

  window.removeArea = function(i){
    state.areas.splice(i,1);
    renderAreasList();
    render();
    recalcSummary();
  };

  function renderAreasList(){
    if (state.areas.length === 0){
      areasList.innerHTML = `<div class="hint">No areas yet. Trace an area on the plan and click “Finish area”.</div>`;
      return;
    }

    areasList.innerHTML = state.areas.map((a, idx) => `
      <div class="item">
        <div class="itemHead">
          <div>
            <strong>${escapeHtml(a.name)}</strong><br/>
            <small class="mono">${a.areaSqft.toFixed(2)} sq ft</small>
          </div>
          <div class="itemBtns">
            <button class="secondary" type="button" onclick="removeArea(${idx})">Delete</button>
          </div>
        </div>
      </div>
    `).join("");
  }

  // ---------------------------
  // Summary
  // ---------------------------
  function recalcSummary(){
    const wastePct = parseFloat(wastePctEl.value) || 0;
    const sqftPerBox = parseFloat(sqftPerBoxEl.value);

    const subtotal = state.areas.reduce((s,a) => s + (a.areaSqft || 0), 0);
    const waste = subtotal * (wastePct / 100);
    const total = subtotal + waste;

    sumSubtotal.textContent = subtotal.toFixed(2);
    sumWaste.textContent = waste.toFixed(2);
    sumTotal.textContent = total.toFixed(2);

    if (Number.isFinite(sqftPerBox) && sqftPerBox > 0){
      sumBoxes.textContent = String(Math.ceil(total / sqftPerBox));
    } else {
      sumBoxes.textContent = "—";
    }
  }

  wastePctEl.addEventListener("input", recalcSummary);
  sqftPerBoxEl.addEventListener("input", recalcSummary);

  // ---------------------------
  // OCR Dimension Detection (FIXED: supports "16 x 12")
  // ---------------------------
  btnDetect.addEventListener("click", async () => {
    if (!state._img || state.ocrBusy) return;

    state.ocrBusy = true;
    btnDetect.disabled = true;
    btnDetect.textContent = "Detecting… (OCR)";
    setOcrStatus("starting");

    try {
      // Draw to canvas for OCR
      const ocrCanvas = document.createElement("canvas");
      ocrCanvas.width = state.imgWidth;
      ocrCanvas.height = state.imgHeight;
      const ocrCtx = ocrCanvas.getContext("2d");
      ocrCtx.drawImage(state._img, 0, 0);

      // Light preprocessing: grayscale + contrast threshold (helps colored dimension text)
      const imgData = ocrCtx.getImageData(0, 0, ocrCanvas.width, ocrCanvas.height);
      const d = imgData.data;
      for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i+1], b = d[i+2];
        const gray = (r * 0.299 + g * 0.587 + b * 0.114);
        const v = gray > 170 ? 255 : (gray < 80 ? 0 : gray);
        d[i] = d[i+1] = d[i+2] = v;
      }
      ocrCtx.putImageData(imgData, 0, 0);

      const result = await Tesseract.recognize(
        ocrCanvas,
        "eng",
        {
          tessedit_char_whitelist: "0123456789xX×'\"-.,ftFT ",
          logger: (m) => {
            if (m && m.status) {
              const pct = (typeof m.progress === "number") ? ` ${(m.progress * 100).toFixed(0)}%` : "";
              setOcrStatus(`${m.status}${pct}`);
            }
          }
        }
      );

      const dims = extractDimensionsFromOcr(result.data);
      state.dims = dims.sort((a,b) => (b.conf||0) - (a.conf||0)).slice(0, 80);

      if (state.dims.length && !state.selectedDimId) {
        selectDim(state.dims[0].id);
      }

      renderDimsList();
      render();
      setOcrStatus(`done (${state.dims.length} found)`);
    } catch (err) {
      console.error(err);
      alert("OCR failed. Try a clearer PDF/image or a higher-res plan export.");
      setOcrStatus("error");
    } finally {
      state.ocrBusy = false;
      btnDetect.disabled = !state._img;
      btnDetect.textContent = "Detect dimensions (OCR)";
    }
  });

  function extractDimensionsFromOcr(data){
    const out = [];
    let idCounter = 1;

    const words = data?.words || [];

    // Normalize OCR chars: primes/quotes and multiplication sign
    const norm = (s) => String(s || "")
      .replace(/[’′]/g, "'")
      .replace(/[”″]/g, '"')
      .replace(/[×]/g, "x")
      .trim();

    const normBox = (bb) => ({
      x0: bb.x0 ?? bb.left ?? bb.x ?? 0,
      y0: bb.y0 ?? bb.top ?? bb.y ?? 0,
      x1: bb.x1 ?? (bb.left + bb.width) ?? 0,
      y1: bb.y1 ?? (bb.top + bb.height) ?? 0
    });

    // 1) Single dimensions like 16', 12'-6", OR bare numbers like 16
    for (const w of words){
      const t = norm(w.text);
      const parsed = parseSingleDim(t);
      if (!parsed) continue;

      const bb = w.bbox || w.boundingBox;
      if (!bb) continue;

      out.push({
        id: `d${idCounter++}`,
        raw: parsed.raw,
        feet: parsed.feet,
        bbox: normBox(bb),
        conf: w.confidence ?? data.confidence ?? 0
      });
    }

    // 2) Room size patterns: "16 x 12" often appears as 3 words: 16, x, 12
    for (let i = 0; i < words.length - 2; i++){
      const a = norm(words[i].text);
      const mid = norm(words[i+1].text);
      const b = norm(words[i+2].text);

      if (!/^\d{1,3}$/.test(a)) continue;
      if (!/^(x|X)$/i.test(mid)) continue;
      if (!/^\d{1,3}$/.test(b)) continue;

      const A = parseInt(a, 10);
      const B = parseInt(b, 10);
      if (A < 2 || A > 500 || B < 2 || B > 500) continue;

      const bb1 = normBox(words[i].bbox || words[i].boundingBox || {});
      const bb2 = normBox(words[i+1].bbox || words[i+1].boundingBox || {});
      const bb3 = normBox(words[i+2].bbox || words[i+2].boundingBox || {});

      const bbox = {
        x0: Math.min(bb1.x0, bb2.x0, bb3.x0),
        y0: Math.min(bb1.y0, bb2.y0, bb3.y0),
        x1: Math.max(bb1.x1, bb2.x1, bb3.x1),
        y1: Math.max(bb1.y1, bb2.y1, bb3.y1)
      };

      const conf = Math.round(((words[i].confidence ?? 0) + (words[i+1].confidence ?? 0) + (words[i+2].confidence ?? 0)) / 3);

      // Add both candidates so user can pick either for scaling
      out.push({ id: `d${idCounter++}`, raw: `${A}'`, feet: A, bbox, conf });
      out.push({ id: `d${idCounter++}`, raw: `${B}'`, feet: B, bbox, conf });
    }

    return dedupeDims(out);
  }

  function parseSingleDim(text){
    const t = String(text || "").trim();
    if (!t) return null;

    // Accept formats like: 12'-6", 12' 6", 12'6"
    let m = t.match(/^(\d{1,3})\s*'\s*(?:-|\s)?\s*(\d{1,2})\s*"?$/);
    if (m){
      const ft = parseInt(m[1],10);
      const inch = m[2] ? parseInt(m[2],10) : 0;
      if (!Number.isFinite(ft) || ft < 2 || ft > 500) return null;
      if (!Number.isFinite(inch) || inch < 0 || inch >= 12) return null;
      const feet = ft + inch/12;
      return { feet, raw: inch ? `${ft}'-${inch}"` : `${ft}'` };
    }

    // Accept pure feet like "16'" or even "16"
    m = t.match(/^(\d{1,3})\s*'?$/);
    if (m){
      const ft = parseInt(m[1],10);
      if (!Number.isFinite(ft) || ft < 2 || ft > 500) return null;
      return { feet: ft, raw: `${ft}'` };
    }

    return null;
  }

  function dedupeDims(dims){
    const kept = [];
    for (const d of dims){
      const tooClose = kept.some(k =>
        Math.abs(k.feet - d.feet) < 0.01 &&
        overlapRatio(k.bbox, d.bbox) > 0.35
      );
      if (!tooClose) kept.push(d);
    }
    return kept;
  }

  function overlapRatio(a,b){
    if (!a || !b) return 0;
    const xA = Math.max(a.x0, b.x0);
    const yA = Math.max(a.y0, b.y0);
    const xB = Math.min(a.x1, b.x1);
    const yB = Math.min(a.y1, b.y1);
    const inter = Math.max(0, xB-xA) * Math.max(0, yB-yA);
    const areaA = Math.max(0, a.x1-a.x0) * Math.max(0, a.y1-a.y0);
    const areaB = Math.max(0, b.x1-b.x0) * Math.max(0, b.y1-b.y0);
    const denom = Math.min(areaA, areaB) || 1;
    return inter / denom;
  }

  function renderDimsList(){
    if (!state.dims.length){
      dimsList.innerHTML = `<div class="hint">No detected dimensions yet. Click “Detect dimensions (OCR)”.</div>`;
      return;
    }

    dimsList.innerHTML = state.dims.map(d => {
      const selected = (d.id === state.selectedDimId);
      return `
        <div class="item">
          <div class="itemHead">
            <div>
              <strong>${escapeHtml(d.raw)}</strong>
              <div class="hint mono">${d.feet.toFixed(3)} ft • conf ${Math.round(d.conf || 0)}</div>
            </div>
            <div class="itemBtns">
              <button type="button" class="${selected ? "" : "secondary"}" onclick="selectDim('${d.id}')">
                ${selected ? "Selected" : "Use for scale"}
              </button>
            </div>
          </div>
        </div>
      `;
    }).join("");
  }

  window.selectDim = function(id){ selectDim(id); };

  function selectDim(id){
    const d = state.dims.find(x => x.id === id);
    if (!d) return;

    state.selectedDimId = d.id;
    state.selectedDimFeet = d.feet;

    // Switch user to calibrate
    state.mode = "calibrate";
    modeSelect.value = "calibrate";

    // Clear calibration points to avoid mixing
    state.calibratePts = [];
    updateReadouts();
    renderDimsList();
    render();
  }

  function findClickedDim(imgPt){
    for (const d of state.dims){
      const b = d.bbox;
      if (imgPt.x >= b.x0 && imgPt.x <= b.x1 && imgPt.y >= b.y0 && imgPt.y <= b.y1) return d;
    }
    return null;
  }

  // ---------------------------
  // Export JSON
  // ---------------------------
  btnExport.addEventListener("click", () => {
    const payload = {
      ftPerPixel: state.ftPerPixel,
      selectedDimFeet: state.selectedDimFeet,
      dimsFound: state.dims.map(d => ({ raw: d.raw, feet: d.feet, conf: d.conf })),
      areas: state.areas.map(a => ({ name: a.name, areaSqft: a.areaSqft })),
      totals: {
        subtotalSqft: parseFloat(sumSubtotal.textContent),
        wasteSqft: parseFloat(sumWaste.textContent),
        totalSqft: parseFloat(sumTotal.textContent),
        boxes: sumBoxes.textContent
      }
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "flooring-takeoff.json";
    a.click();
    URL.revokeObjectURL(url);
  });

  // ---------------------------
  // Init
  // ---------------------------
  window.addEventListener("resize", resizeCanvases);
  resizeCanvases();
  updateReadouts();
  setOcrStatus("idle");
  renderDimsList();
  renderAreasList();
  recalcSummary();
</script>
</body>
</html>
