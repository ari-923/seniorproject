<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flooring Takeoff (MVP)</title>

  <!-- PDF.js (CDN). For production, you can self-host these files. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.js"></script>

  <style>
    :root { --bg:#f6f7f9; --card:#fff; --line:#e6e8ee; --text:#111827; --muted:#6b7280; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: var(--bg); color: var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; }
    header { display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    h1 { margin: 0; font-size: 18px; }
    .grid { display:grid; grid-template-columns: 1.35fr 0.65fr; gap: 14px; margin-top: 12px; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }

    .card { background: var(--card); border: 1px solid var(--line); border-radius: 12px; padding: 12px; }
    .row { display:grid; grid-template-columns: repeat(12, 1fr); gap: 10px; }
    .col-12{ grid-column: span 12; } .col-6{ grid-column: span 6; } .col-4{ grid-column: span 4; } .col-3{ grid-column: span 3; }
    @media (max-width: 680px){ .col-6,.col-4,.col-3{ grid-column: span 12; } }

    label { display:block; font-size: 12px; color: var(--muted); margin: 0 0 6px; }
    input, select, button {
      width:100%; box-sizing:border-box; padding:10px; border: 1px solid #d7dbe6; border-radius: 10px; font-size: 14px;
      background:#fff;
    }
    button { cursor:pointer; background:#111827; color:#fff; border:1px solid #111827; }
    button.secondary { background:#fff; color:#111827; border-color:#cfd5e5; }
    button.ghost { background:#fff; color:#111827; border-color:#e5e7eb; }
    .hint { font-size: 12px; color: var(--muted); line-height: 1.35; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; border:1px solid var(--line); border-radius: 999px; font-size: 12px; color: var(--muted); background:#fff; }
    .toolbar { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top: 10px; }
    .toolbar > * { flex: 1 1 160px; }

    /* Viewer */
    .viewer {
      position: relative;
      width: 100%;
      height: 72vh;
      min-height: 520px;
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      background: #0b1220;
      touch-action: none;
    }
    @media (max-width: 980px){
      .viewer { height: 65vh; min-height: 480px; }
    }

    canvas { display:block; }
    #baseCanvas, #overlayCanvas {
      position:absolute; left:0; top:0;
      transform-origin: 0 0;
    }

    .status {
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top: 10px;
    }

    .list { display:flex; flex-direction:column; gap:10px; margin-top: 10px; }
    .item { border: 1px solid var(--line); border-radius: 12px; padding: 10px; }
    .itemHead { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .item strong { font-size: 14px; }
    .item small { color: var(--muted); }
    .itemBtns { display:flex; gap:8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .big { font-size: 18px; font-weight: 800; }
    .line { display:flex; justify-content:space-between; gap:12px; padding: 8px 0; border-bottom: 1px dashed var(--line); }
    .line:last-child { border-bottom:none; }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>Flooring Takeoff (Upload → Scale → Trace → Boxes)</h1>
      <span class="pill">MVP: reliable tracing (no AI guessing)</span>
    </header>

    <div class="grid">
      <!-- LEFT: Viewer -->
      <section class="card">
        <div class="row">
          <div class="col-6">
            <label>Upload blueprint (PDF / JPG / PNG)</label>
            <input id="fileInput" type="file" accept=".pdf,image/*" />
          </div>
          <div class="col-3">
            <label>Mode</label>
            <select id="modeSelect">
              <option value="pan">Pan / Zoom</option>
              <option value="calibrate">Set Scale</option>
              <option value="trace">Trace Area</option>
            </select>
          </div>
          <div class="col-3">
            <label>Room / Area name</label>
            <input id="areaName" placeholder="Living Room" />
          </div>
        </div>

        <div class="toolbar">
          <button class="secondary" type="button" id="btnUndo">Undo point</button>
          <button class="secondary" type="button" id="btnClear">Clear current</button>
          <button type="button" id="btnFinish">Finish area</button>
          <button class="ghost" type="button" id="btnResetView">Reset view</button>
        </div>

        <div class="status">
          <span class="pill">Scale: <span class="mono" id="scaleReadout">not set</span></span>
          <span class="pill">Current points: <span class="mono" id="pointsReadout">0</span></span>
          <span class="pill">Tip: double-click to finish polygon</span>
        </div>

        <div class="hint" style="margin-top:10px">
          <b>Workflow:</b>
          1) Upload blueprint → 2) Mode: <b>Set Scale</b> (click 2 points on a known dimension, enter the real length in feet)
          → 3) Mode: <b>Trace Area</b> (click corners around a room) → Finish.
          <br/>Use <b>Pan/Zoom</b> mode to move around. Trackpad pinch / mouse wheel zoom supported.
        </div>

        <div style="height:12px"></div>

        <div class="viewer" id="viewer">
          <canvas id="baseCanvas"></canvas>
          <canvas id="overlayCanvas"></canvas>
        </div>
      </section>

      <!-- RIGHT: Summary -->
      <aside class="card">
        <div class="row">
          <div class="col-6">
            <label>Waste %</label>
            <input id="wastePct" type="number" step="0.1" value="10" />
          </div>
          <div class="col-6">
            <label>Sq ft per box (optional)</label>
            <input id="sqftPerBox" type="number" step="0.01" placeholder="18.6" />
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="line"><div class="hint">Subtotal (sq ft)</div><div class="mono" id="sumSubtotal">0.00</div></div>
        <div class="line"><div class="hint">Waste (sq ft)</div><div class="mono" id="sumWaste">0.00</div></div>
        <div class="line"><div class="hint">Total (sq ft)</div><div class="mono" id="sumTotal">0.00</div></div>
        <div class="line"><div class="hint">Boxes needed</div><div class="mono" id="sumBoxes">—</div></div>

        <div style="height:12px"></div>
        <div class="big">Areas</div>

        <div class="list" id="areasList"></div>

        <div style="height:12px"></div>
        <button class="secondary" type="button" id="btnExport">Export JSON (dev)</button>
        <div class="hint" style="margin-top:8px">
          Export is for developers (you can later save projects to a database).
        </div>
      </aside>
    </div>
  </div>

<script>
  // ---------------------------
  // State
  // ---------------------------
  const state = {
    imgWidth: 0,
    imgHeight: 0,
    // view transform
    scale: 1,
    minScale: 0.2,
    maxScale: 8,
    offsetX: 0,
    offsetY: 0,
    // Interaction
    mode: "pan",
    dragging: false,
    lastDrag: null,

    // Calibration
    calibratePts: [], // two points in image coords
    ftPerPixel: null, // scale

    // Tracing
    currentPts: [], // polygon points in image coords
    areas: [] // {name, pts, areaSqft}
  };

  // ---------------------------
  // DOM
  // ---------------------------
  const viewer = document.getElementById("viewer");
  const baseCanvas = document.getElementById("baseCanvas");
  const overlayCanvas = document.getElementById("overlayCanvas");
  const baseCtx = baseCanvas.getContext("2d");
  const overlayCtx = overlayCanvas.getContext("2d");

  const fileInput = document.getElementById("fileInput");
  const modeSelect = document.getElementById("modeSelect");
  const areaName = document.getElementById("areaName");

  const btnUndo = document.getElementById("btnUndo");
  const btnClear = document.getElementById("btnClear");
  const btnFinish = document.getElementById("btnFinish");
  const btnResetView = document.getElementById("btnResetView");
  const btnExport = document.getElementById("btnExport");

  const scaleReadout = document.getElementById("scaleReadout");
  const pointsReadout = document.getElementById("pointsReadout");

  const wastePctEl = document.getElementById("wastePct");
  const sqftPerBoxEl = document.getElementById("sqftPerBox");

  const sumSubtotal = document.getElementById("sumSubtotal");
  const sumWaste = document.getElementById("sumWaste");
  const sumTotal = document.getElementById("sumTotal");
  const sumBoxes = document.getElementById("sumBoxes");
  const areasList = document.getElementById("areasList");

  // ---------------------------
  // Helpers
  // ---------------------------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function dist(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.hypot(dx, dy);
  }

  // Shoelace area in pixel^2
  function polygonAreaPx2(pts){
    if (pts.length < 3) return 0;
    let sum = 0;
    for (let i=0; i<pts.length; i++){
      const j = (i+1) % pts.length;
      sum += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
    }
    return Math.abs(sum) / 2;
  }

  function toMoney(n){
    return new Intl.NumberFormat(undefined, { maximumFractionDigits: 2 }).format(n);
  }

  function updateReadouts(){
    scaleReadout.textContent = state.ftPerPixel ? `${state.ftPerPixel.toFixed(6)} ft/px` : "not set";
    pointsReadout.textContent = String(state.mode === "calibrate" ? state.calibratePts.length : state.currentPts.length);
  }

  // Convert screen coords → image coords (inverse of view transform)
  function screenToImage(pt){
    return {
      x: (pt.x - state.offsetX) / state.scale,
      y: (pt.y - state.offsetY) / state.scale
    };
  }

  // Convert image coords → screen coords
  function imageToScreen(pt){
    return {
      x: pt.x * state.scale + state.offsetX,
      y: pt.y * state.scale + state.offsetY
    };
  }

  function resizeCanvases(){
    const dpr = window.devicePixelRatio || 1;
    const rect = viewer.getBoundingClientRect();

    // Set internal pixel size to match display * dpr
    baseCanvas.width = Math.floor(rect.width * dpr);
    baseCanvas.height = Math.floor(rect.height * dpr);
    overlayCanvas.width = baseCanvas.width;
    overlayCanvas.height = baseCanvas.height;

    // Set CSS size
    baseCanvas.style.width = rect.width + "px";
    baseCanvas.style.height = rect.height + "px";
    overlayCanvas.style.width = rect.width + "px";
    overlayCanvas.style.height = rect.height + "px";

    baseCtx.setTransform(dpr,0,0,dpr,0,0);
    overlayCtx.setTransform(dpr,0,0,dpr,0,0);

    render();
  }

  function resetView(){
    // Fit image to viewer
    const rect = viewer.getBoundingClientRect();
    if (!state.imgWidth || !state.imgHeight) return;

    const scaleX = rect.width / state.imgWidth;
    const scaleY = rect.height / state.imgHeight;
    const fit = Math.min(scaleX, scaleY);

    state.scale = clamp(fit, state.minScale, state.maxScale);
    state.offsetX = (rect.width - state.imgWidth * state.scale) / 2;
    state.offsetY = (rect.height - state.imgHeight * state.scale) / 2;
    render();
  }

  function clearCurrent(){
    state.currentPts = [];
    state.calibratePts = [];
    updateReadouts();
    render();
  }

  function undoPoint(){
    if (state.mode === "calibrate"){
      state.calibratePts.pop();
    } else if (state.mode === "trace"){
      state.currentPts.pop();
    }
    updateReadouts();
    render();
  }

  function render(){
    const rect = viewer.getBoundingClientRect();
    baseCtx.clearRect(0,0,rect.width, rect.height);
    overlayCtx.clearRect(0,0,rect.width, rect.height);

    // base layer (blueprint image already painted into baseCanvas using drawImage on renderImage)
    // here we just redraw from an offscreen image if available
    if (state._img){
      // draw blueprint
      baseCtx.save();
      baseCtx.setTransform(1,0,0,1,0,0);
      baseCtx.clearRect(0,0,rect.width, rect.height);
      baseCtx.restore();

      baseCtx.save();
      baseCtx.translate(state.offsetX, state.offsetY);
      baseCtx.scale(state.scale, state.scale);
      baseCtx.drawImage(state._img, 0, 0);
      baseCtx.restore();
    }

    // overlay: calibration line / points and current polygon + stored polygons
    overlayCtx.save();
    overlayCtx.lineWidth = 2;
    overlayCtx.strokeStyle = "rgba(0, 255, 170, 0.95)";
    overlayCtx.fillStyle = "rgba(0, 255, 170, 0.18)";

    // Draw existing areas
    for (const a of state.areas){
      drawPolygonScreen(a.pts, "rgba(59, 130, 246, 0.95)", "rgba(59, 130, 246, 0.18)");
    }

    // Mode-specific draws
    if (state.mode === "calibrate"){
      drawPointsAndLine(state.calibratePts, "rgba(0,255,170,0.95)");
    } else if (state.mode === "trace"){
      if (state.currentPts.length >= 2){
        drawPolygonScreen(state.currentPts, "rgba(16, 185, 129, 0.95)", "rgba(16, 185, 129, 0.18)", false);
      }
      drawPoints(state.currentPts, "rgba(16,185,129,0.95)");
    }
    overlayCtx.restore();
  }

  function drawPoints(pts, color){
    const rect = viewer.getBoundingClientRect();
    overlayCtx.save();
    overlayCtx.strokeStyle = color;
    overlayCtx.fillStyle = color;
    for (const p of pts){
      const s = imageToScreen(p);
      overlayCtx.beginPath();
      overlayCtx.arc(s.x, s.y, 4, 0, Math.PI*2);
      overlayCtx.fill();
    }
    overlayCtx.restore();
  }

  function drawPointsAndLine(pts, color){
    overlayCtx.save();
    overlayCtx.strokeStyle = color;
    overlayCtx.fillStyle = color;

    if (pts.length >= 1){
      drawPoints(pts, color);
    }
    if (pts.length === 2){
      const a = imageToScreen(pts[0]);
      const b = imageToScreen(pts[1]);
      overlayCtx.beginPath();
      overlayCtx.moveTo(a.x, a.y);
      overlayCtx.lineTo(b.x, b.y);
      overlayCtx.stroke();
    }
    overlayCtx.restore();
  }

  function drawPolygonScreen(pts, stroke, fill, closed=true){
    if (pts.length < 2) return;
    overlayCtx.save();
    overlayCtx.strokeStyle = stroke;
    overlayCtx.fillStyle = fill;

    const p0 = imageToScreen(pts[0]);
    overlayCtx.beginPath();
    overlayCtx.moveTo(p0.x, p0.y);
    for (let i=1; i<pts.length; i++){
      const s = imageToScreen(pts[i]);
      overlayCtx.lineTo(s.x, s.y);
    }
    if (closed && pts.length >= 3) overlayCtx.closePath();
    overlayCtx.stroke();
    if (closed && pts.length >= 3) overlayCtx.fill();
    overlayCtx.restore();
  }

  // ---------------------------
  // Loading Files (PDF / Image)
  // ---------------------------
  fileInput.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    clearAllData();

    if (file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf")){
      await loadPdfFirstPage(file);
    } else {
      await loadImageFile(file);
    }
    resizeCanvases();
    resetView();
    updateReadouts();
    recalcSummary();
  });

  function clearAllData(){
    state._img = null;
    state.imgWidth = 0;
    state.imgHeight = 0;
    state.ftPerPixel = null;
    state.calibratePts = [];
    state.currentPts = [];
    state.areas = [];
    renderAreasList();
  }

  async function loadImageFile(file){
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.crossOrigin = "anonymous";
    await new Promise((res, rej) => {
      img.onload = res;
      img.onerror = rej;
      img.src = url;
    });
    state._img = img;
    state.imgWidth = img.naturalWidth;
    state.imgHeight = img.naturalHeight;
    URL.revokeObjectURL(url);
  }

  async function loadPdfFirstPage(file){
    const arr = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arr }).promise;
    const page = await pdf.getPage(1);

    // render at high resolution for readability
    const viewport = page.getViewport({ scale: 2.0 });

    const off = document.createElement("canvas");
    off.width = Math.floor(viewport.width);
    off.height = Math.floor(viewport.height);
    const ctx = off.getContext("2d");

    await page.render({ canvasContext: ctx, viewport }).promise;

    // Convert rendered canvas to Image
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = off.toDataURL("image/png");
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });

    state._img = img;
    state.imgWidth = img.naturalWidth;
    state.imgHeight = img.naturalHeight;
  }

  // ---------------------------
  // Interaction: modes
  // ---------------------------
  modeSelect.addEventListener("change", () => {
    state.mode = modeSelect.value;
    state.dragging = false;
    state.lastDrag = null;
    updateReadouts();
    render();
  });

  btnResetView.addEventListener("click", resetView);
  btnUndo.addEventListener("click", undoPoint);
  btnClear.addEventListener("click", clearCurrent);

  btnFinish.addEventListener("click", () => {
    if (state.mode === "calibrate") finishCalibration();
    if (state.mode === "trace") finishArea();
  });

  viewer.addEventListener("dblclick", (e) => {
    if (state.mode === "trace"){
      e.preventDefault();
      finishArea();
    }
  });

  // Pan/Zoom + Click placement
  viewer.addEventListener("pointerdown", (e) => {
    if (!state._img) return;
    viewer.setPointerCapture(e.pointerId);

    const pt = getViewerPoint(e);

    if (state.mode === "pan"){
      state.dragging = true;
      state.lastDrag = pt;
      return;
    }

    // In calibrate/trace, still allow drag with right click / two-finger? (simple: shift+drag)
    if (e.shiftKey){
      state.dragging = true;
      state.lastDrag = pt;
      return;
    }

    // Place point
    const imgPt = screenToImage(pt);
    if (imgPt.x < 0 || imgPt.y < 0 || imgPt.x > state.imgWidth || imgPt.y > state.imgHeight) return;

    if (state.mode === "calibrate"){
      if (state.calibratePts.length < 2){
        state.calibratePts.push(imgPt);
        updateReadouts();
        render();
        if (state.calibratePts.length === 2){
          finishCalibration();
        }
      }
    } else if (state.mode === "trace"){
      state.currentPts.push(imgPt);
      updateReadouts();
      render();
    }
  });

  viewer.addEventListener("pointermove", (e) => {
    if (!state._img) return;
    if (!state.dragging) return;

    const pt = getViewerPoint(e);
    const dx = pt.x - state.lastDrag.x;
    const dy = pt.y - state.lastDrag.y;

    state.offsetX += dx;
    state.offsetY += dy;
    state.lastDrag = pt;
    render();
  });

  viewer.addEventListener("pointerup", (e) => {
    state.dragging = false;
    state.lastDrag = null;
  });

  // Zoom
  viewer.addEventListener("wheel", (e) => {
    if (!state._img) return;
    e.preventDefault();

    const rect = viewer.getBoundingClientRect();
    const mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top };

    const zoomFactor = (e.deltaY < 0) ? 1.10 : 0.90;
    const newScale = clamp(state.scale * zoomFactor, state.minScale, state.maxScale);

    // zoom around cursor: keep image point under mouse stable
    const before = screenToImage(mouse);
    state.scale = newScale;
    const after = screenToImage(mouse);

    state.offsetX += (after.x - before.x) * state.scale;
    state.offsetY += (after.y - before.y) * state.scale;

    render();
  }, { passive: false });

  function getViewerPoint(e){
    const rect = viewer.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  // ---------------------------
  // Calibration + Tracing
  // ---------------------------
  function finishCalibration(){
    if (state.calibratePts.length !== 2) return;

    const px = dist(state.calibratePts[0], state.calibratePts[1]);
    if (px <= 0) return;

    const input = prompt("Enter the REAL distance between those two points (in FEET). Example: 12.5");
    if (input == null) return;

    const feet = parseFloat(input);
    if (!Number.isFinite(feet) || feet <= 0){
      alert("Invalid feet value.");
      return;
    }

    state.ftPerPixel = feet / px;
    updateReadouts();
    render();
    recalcSummary();
  }

  function finishArea(){
    if (!state.ftPerPixel){
      alert("Set the scale first (Mode: Set Scale).");
      return;
    }
    if (state.currentPts.length < 3){
      alert("Trace at least 3 points to make an area.");
      return;
    }

    const name = areaName.value.trim() || `Area ${state.areas.length + 1}`;
    const px2 = polygonAreaPx2(state.currentPts);

    // Convert px^2 -> ft^2 using (ft/px)^2
    const ft2 = px2 * (state.ftPerPixel * state.ftPerPixel);

    state.areas.push({
      name,
      pts: structuredClone(state.currentPts),
      areaSqft: ft2
    });

    state.currentPts = [];
    updateReadouts();
    renderAreasList();
    render();
    recalcSummary();
  }

  function renderAreasList(){
    if (state.areas.length === 0){
      areasList.innerHTML = `<div class="hint">No areas yet. Trace an area on the plan and click “Finish area”.</div>`;
      return;
    }

    areasList.innerHTML = state.areas.map((a, idx) => {
      return `
        <div class="item">
          <div class="itemHead">
            <div>
              <strong>${escapeHtml(a.name)}</strong><br/>
              <small class="mono">${a.areaSqft.toFixed(2)} sq ft</small>
            </div>
            <div class="itemBtns">
              <button class="secondary" type="button" onclick="removeArea(${idx})">Delete</button>
            </div>
          </div>
        </div>
      `;
    }).join("");
  }

  window.removeArea = function(i){
    state.areas.splice(i,1);
    renderAreasList();
    render();
    recalcSummary();
  }

  function recalcSummary(){
    const wastePct = parseFloat(wastePctEl.value) || 0;
    const sqftPerBox = parseFloat(sqftPerBoxEl.value);

    const subtotal = state.areas.reduce((s,a) => s + (a.areaSqft || 0), 0);
    const waste = subtotal * (wastePct / 100);
    const total = subtotal + waste;

    sumSubtotal.textContent = subtotal.toFixed(2);
    sumWaste.textContent = waste.toFixed(2);
    sumTotal.textContent = total.toFixed(2);

    if (Number.isFinite(sqftPerBox) && sqftPerBox > 0){
      sumBoxes.textContent = String(Math.ceil(total / sqftPerBox));
    } else {
      sumBoxes.textContent = "—";
    }
  }

  wastePctEl.addEventListener("input", recalcSummary);
  sqftPerBoxEl.addEventListener("input", recalcSummary);

  // Export JSON for later “save project”
  btnExport.addEventListener("click", () => {
    const payload = {
      ftPerPixel: state.ftPerPixel,
      areas: state.areas.map(a => ({ name: a.name, areaSqft: a.areaSqft })),
      totals: {
        subtotalSqft: parseFloat(sumSubtotal.textContent),
        wasteSqft: parseFloat(sumWaste.textContent),
        totalSqft: parseFloat(sumTotal.textContent),
        boxes: sumBoxes.textContent
      }
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "flooring-takeoff.json";
    a.click();
    URL.revokeObjectURL(url);
  });

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[s]));
  }

  // Resize handling
  window.addEventListener("resize", resizeCanvases);
  resizeCanvases();
  updateReadouts();
  renderAreasList();
</script>
</body>
</html>
